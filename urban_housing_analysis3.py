# -*- coding: utf-8 -*-
"""urban_housing_analysis3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eCyNzDXRrFVMn3DR_O5eX5aqVH4W9CCT
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""# Data Import & Initial Data Check"""

# Load the dataset
file_path = "/content/housing.csv"
df = pd.read_csv(file_path)
# Display first few rows
df.head()

"""# Data Preprocessing

## Structural Investigation
"""

df.shape

df.info()

df.describe()

# Check unique values for categorical variables
df["State"].unique()

df["District"].unique()

df["House_Type"].unique()

"""## Quality Investigation"""

df.isnull().sum()

df.duplicated().sum()

"""## Data Cleaning"""

# Counts of each values in categorical variables before handling missing values
print('Categorical Variable: Value Counts Before Imputation\n')
print('-------------------------------------------------------------')
print(df['State'].value_counts(),'\n')
print(df['District'].value_counts(),'\n')
print(df['House_Type'].value_counts())

# Handling missing value for House_Overhang with 0
# df["House_Overhang"].fillna(0, inplace=True)

# Handling missing value for House_Overhang with median
df["House_Overhang"] = df.groupby(["State", "House_Type"])["House_Overhang"].transform(lambda x: x.fillna(x.median()))

# Handling missing value for House_Price with median
df["House_Price"] = df.groupby(["State", "House_Type"])["House_Price"].transform(lambda x: x.fillna(x.median()))

# Handling missing value for House_Supply with median
df["House_Supply"] = df.groupby(["State", "District", "House_Type"])["House_Supply"].transform(lambda x: x.fillna(x.median()))

# Checking for missing value after imputation
df.isnull().sum()

"""### Feature Engineering"""

# To better understand housing demand, and easier to visualize on dashboard
df["House_Demand"] = df["House_Supply"] - df["House_Overhang"]

"""# Exploratory Data Investigation (EDA)"""

# Check distribution for numerical features
num_cols = ["GDP", "House_Overhang", "House_Price", "House_Supply", "Inflation_Rate", "Interest_Rate", "Population", "Unemployment_Rate"]

plt.figure(figsize=(15, 10))
for i, col in enumerate(num_cols, 1):
    plt.subplot(3, 3, i)
    sns.histplot(df[col], kde=True, bins=30)
    plt.title(f"Distribution of {col}")
plt.tight_layout()
plt.show()

## Check for imbalances in categorical features

fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# State Distribution
sns.countplot(x='State', data=df, ax=axes[0], palette="viridis")
axes[0].set_title("State Distribution")
axes[0].set_xlabel("State")
axes[0].set_ylabel("Count")

# House Type Distribution
sns.countplot(x='House_Type', data=df, ax=axes[1], palette="magma")
axes[1].set_title("House Type Distribution")
axes[1].set_xlabel("House Type")
axes[1].set_ylabel("Count")
axes[1].tick_params(axis='x', rotation=45)  # Rotate x labels for readability

plt.tight_layout()
plt.show()

## Correlation Analysis of Original Numerical Features vs House_Price
num_cols_noPrice = ['House_Overhang','House_Supply','Interest_Rate',
                'Inflation_Rate', 'GDP', 'Unemployment_Rate', 'Population']

# Create heatmap
plt.figure(figsize=(8, 5))
sns.heatmap(df[num_cols_noPrice + ['House_Price']].corr(), annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)

# Title
plt.title("Correlation Matrix of Numerical Features VS House_Price")

# Show plot
plt.show()

# Identify TOP 3 influential numerical factors affecting house price

# Compute correlation
correlation_matrix = df[num_cols_noPrice + ['House_Price']].corr()

# Sort by correlation with House_Price (descending)
correlation_sorted = correlation_matrix['House_Price'].abs().sort_values(ascending=False)

# Display top 3 most influential numerical factors
top_numerical_factors = correlation_sorted[1:4]  # Exclude House_Price itself

# Visualization
plt.figure(figsize=(8, 5))
sns.barplot(x=top_numerical_factors.values, y=top_numerical_factors.index, palette="Blues_r")
plt.xlabel("Correlation with House Price")
plt.ylabel("Feature")
plt.title("Top 3 Influential Numerical Factors Affecting House Price")
plt.show()

## Compare median prices across house types
df.groupby('House_Type')['House_Price'].median().sort_values().plot(kind='barh', figsize=(8, 5), color='skyblue')

plt.xlabel("Median House Price (MYR)")
plt.ylabel("House Type")
plt.title("Median House Price Across House Types")
plt.show()

## Statistical Significance using ANOVA Test
import scipy.stats as stats

# Create a list of House_Price values for each House_Type
house_type_groups = [df[df['House_Type'] == ht]['House_Price'] for ht in df['House_Type'].unique()]

# Perform ANOVA
f_stat, p_value = stats.f_oneway(*house_type_groups)

print(f"ANOVA Test Results: F-Statistic = {f_stat:.4f}, P-Value = {p_value:.4f}")

'''
The larger the F-statistic, the greater the difference between groups
P-Value < 0.05: Significant ; > 0.05 Not significant

Now we have these TOP 3 influential numerical factors:
- 'Population' -- approx. 0.4
- 'House_Supply' -- approx. 0.05
- 'Unemployment_Rate' -- apporx. 0.05

For categorical factor, we have:
- House_Type -- P-value: 0.00 ; F-Statistic = 332.9586

Use Eta-Squared (η²) to compute the Effect Size for House_Type, then compare to the
three numerical factors
'''

# Compute total sum of squares (SST)
sst = sum((df['House_Price'] - df['House_Price'].mean())**2)

# Compute sum of squares between groups (SSB)
ssb = sum(df.groupby('House_Type')['House_Price'].count() *
          (df.groupby('House_Type')['House_Price'].mean() - df['House_Price'].mean())**2)

# Compute Eta-Squared
eta_squared = ssb / sst
print(f"Effect Size (Eta-Squared) for House_Type: {eta_squared:.4f}")

'''
Based on the analysis, the TOP 3 influential factors affecting House_Price are:
1. Population (~0.4)
2. House_Type (0.2325 based on Eta-Squared)
3. House_Supply (~0.05)

Method used: Correlation Analysis, ANOVA Test, Eta-Squared for Effect Size

'''

## Export selected features for visualization and analysis
selected_features = [
    'Year', 'State', 'District', 'Quarter', 'House_Type',
    'Interest_Rate', 'Inflation_Rate', 'GDP', 'Unemployment_Rate', 'Population',
    'House_Overhang', 'House_Price', 'House_Supply'
]

df_selected = df[selected_features]

# Save to CSV (without index for cleaner output)
df_selected.to_csv("cleaned_housing_data.csv", index=False)

"""# Visualization

## 1. Historical Housing Price & Demand Trends

### Historical Housing Price by Quarter (Overall Trend)
"""

import plotly.express as px

# Group by Year and Quarter, calculating the mean price
df_price_trend = df.groupby(['Year', 'Quarter'])[['House_Price']].mean().reset_index()

# Convert Quarter into a readable format (e.g., 2015-Q1, 2015-Q2)
df_price_trend['Time'] = df_price_trend['Year'].astype(str) + "-Q" + df_price_trend['Quarter'].astype(str)

# Line Chart
fig = px.line(df_price_trend,
              x='Time',
              y='House_Price',
              title="Historical Housing Price Trends by Quarter (2015-2024)",
              markers=True,
              labels={'House_Price': "Average Price (MYR)"})

fig.update_xaxes(title="Year-Quarter", tickangle=45)
fig.update_yaxes(title="House Price (MYR)", tickformat=",")
fig.show()

"""### Historical Housing Price by Quarter (State-Level Trends)"""

# Group by Year, Quarter, and State, calculating the mean price
df_state_trend = df.groupby(['Year', 'Quarter', 'State'])[['House_Price']].mean().reset_index()
df_state_trend['Time'] = df_state_trend['Year'].astype(str) + "-Q" + df_state_trend['Quarter'].astype(str)

# Line Chart with State Differentiation
fig = px.line(df_state_trend,
              x='Time',
              y='House_Price',
              color='State',
              title="Housing Price Trends by State by Quater (2015-2024)",
              markers=True,
              labels={'House_Price': "Average Price (MYR)"})

fig.update_xaxes(title="Year-Quarter", tickangle=45)
fig.update_yaxes(title="House Price (MYR)", tickformat=",")
fig.show()

"""### Historical Housing Price by Year (Overall Trend)"""

# Group by Year, calculating the mean price
df_price_yearly = df.groupby(['Year'])[['House_Price']].mean().reset_index()

# Line Chart
fig = px.line(df_price_yearly,
              x='Year',
              y='House_Price',
              title="Historical Housing Price Trends (Yearly)",
              markers=True,
              labels={'House_Price': "Average Price (MYR)"})

fig.update_xaxes(title="Year", dtick=1)  # Ensure yearly ticks
fig.update_yaxes(title="House Price (MYR)", tickformat=",")
fig.show()

"""### Historical Housing Price by Year (State-Level Trends)"""

# Group by Year and State, calculating the mean price
df_state_yearly = df.groupby(['Year', 'State'])[['House_Price']].mean().reset_index()

# Line Chart with State Differentiation
fig = px.line(df_state_yearly,
              x='Year',
              y='House_Price',
              color='State',
              title="Housing Price Trends by State (Yearly)",
              markers=True,
              labels={'House_Price': "Average Price (MYR)"})

fig.update_xaxes(title="Year", dtick=1)  # Ensure yearly ticks
fig.update_yaxes(title="House Price (MYR)", tickformat=",")
fig.show()

"""### Historical Trend in Demand by State & District"""

# Group by State and District, Summing up Housing Demand
df_demand = df.groupby(['State', 'District'])[['House_Demand']].sum().reset_index()

# Create Treemap
fig = px.treemap(df_demand,
                 path=['State', 'District'],
                 values='House_Demand',
                 color='House_Demand',
                 color_continuous_scale='YlGnBu',
                 title="Housing Demand by State & District (2015-2024)")

fig.show()

"""## 2. Compare Historical Housing Price Across House Types

###  Average Price by House Type
"""

# Group data: Average House Price by Year and House Type
df_avg_price = df.groupby(['Year', 'House_Type'])[['House_Price']].mean().reset_index()

# Create grouped bar chart
fig = px.bar(df_avg_price,
             x='Year',
             y='House_Price',
             color='House_Type',
             barmode='group',  # Groups bars by house type
             title="Average House Price by House Type (2015-2024)",
             labels={'House_Price': "Average Price (MYR)", 'Year': "Year"})

fig.update_yaxes(title="Average Price (MYR)", tickformat=",")
fig.show()

"""# Modelling

## Check distribution for numerical features
"""

# Check distribution for numerical features
num_cols = ["GDP", "House_Overhang", "House_Price", "House_Supply", "Inflation_Rate", "Interest_Rate", "Population", "Unemployment_Rate"]

plt.figure(figsize=(15, 10))
for i, col in enumerate(num_cols, 1):
    plt.subplot(3, 3, i)
    sns.histplot(df[col], kde=True, bins=30)
    plt.title(f"Distribution of {col}")
plt.tight_layout()
plt.show()

# Checking for outliers in numerical variables
plt.figure(figsize=(15, 8))
for i, col in enumerate(num_cols, 1):
    plt.subplot(3, 3, i)
    sns.boxplot(data=df, y=col)
    plt.title(f"Boxplot of {col}")
plt.tight_layout()
plt.show()

# Normalize distribution using Log Transformation
df["House_Price_Log"] = np.log1p(df["House_Price"])  # log(1+x) to handle zeros
df["House_Overhang_Log"] = np.log1p(df["House_Overhang"])
df["House_Supply_Log"] = np.log1p(df["House_Supply"])
df["House_Demand_Log"] = np.log1p(df["House_Demand"])

fig, axes = plt.subplots(2, 4, figsize=(18, 10))

# Original distributions
sns.histplot(df["House_Price"], bins=50, ax=axes[0, 0], kde=True).set(title="House_Price (Original)")
sns.histplot(df["House_Overhang"], bins=50, ax=axes[0, 1], kde=True).set(title="House_Overhang (Original)")
sns.histplot(df["House_Supply"], bins=50, ax=axes[0, 2], kde=True).set(title="House_Supply (Original)")
sns.histplot(df["House_Demand"], bins=50, ax=axes[0, 3], kde=True).set(title="House_Demand(Original)")


# Log-transformed distributions
sns.histplot(df["House_Price_Log"], bins=50, ax=axes[1, 0], kde=True).set(title="House_Price (Log Transformed)")
sns.histplot(df["House_Overhang_Log"], bins=50, ax=axes[1, 1], kde=True).set(title="House_Overhang (Log Transformed)")
sns.histplot(df["House_Supply_Log"], bins=50, ax=axes[1, 2], kde=True).set(title="House_Supply (Log Transformed)")
sns.histplot(df["House_Demand_Log"], bins=50, ax=axes[1, 3], kde=True).set(title="House_Demand (Log Transformed)")


plt.tight_layout()
plt.show()

# Check for extreme values
# df[["House_Price", "House_Overhang", "House_Supply"]].describe(percentiles=[0.01, 0.25, 0.5, 0.75, 0.99])

# IQR method to identify outliers
def detect_outliers(column):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    return df[(df[column] < lower_bound) | (df[column] > upper_bound)]

outliers_price = detect_outliers("House_Price")
outliers_overhang = detect_outliers("House_Overhang")
outliers_supply = detect_outliers("House_Supply")
outliers_demand = detect_outliers("House_Demand")

print(f"Outliers in House_Price: {outliers_price.shape[0]}")
print(f"Outliers in House_Overhang: {outliers_overhang.shape[0]}")
print(f"Outliers in House_Supply: {outliers_supply.shape[0]}")
print(f"Outliers in House_Demand: {outliers_supply.shape[0]}")

"""## Check imbalances for categorical features"""

## Check Imbalanced for Categorical Features
# Check count distribution
print(df['State'].value_counts(), "\n")
print(df['House_Type'].value_counts())

# Visualization
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# State Distribution
sns.countplot(x='State', data=df, ax=axes[0], palette="viridis")
axes[0].set_title("State Distribution")
axes[0].set_xlabel("State")
axes[0].set_ylabel("Count")

# House Type Distribution
sns.countplot(x='House_Type', data=df, ax=axes[1], palette="magma")
axes[1].set_title("House Type Distribution")
axes[1].set_xlabel("House Type")
axes[1].set_ylabel("Count")
axes[1].tick_params(axis='x', rotation=45)  # Rotate x labels for readability

plt.tight_layout()
plt.show()

